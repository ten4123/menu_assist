// Figma Plugin Code (code.ts)
import { iconData, IconData, VariantProperty, ICON_COMPONENT_SET_KEYS, LayerType, LAYER_Z_INDEX, getLayerType, CustomIconEntry, CustomIconDatabase } from './data/icon-db';
// ë¡œì»¬ ë°ì´í„°/ì„¤ì •ì„ ì¸ë¼ì¸ìœ¼ë¡œ í¬í•¨í•´ ë…ë¦½ ì‹¤í–‰í•©ë‹ˆë‹¤.

// -----------------------------------------------------------
// 1. ì´ˆê¸° ì„¤ì • ë° íƒ€ì… ì •ì˜
// -----------------------------------------------------------

figma.showUI(__html__, { width: 360, height: 550, title: "ì•„ì´ì½˜ ë§¤í•‘ ì œì•ˆ", themeColors: true });

interface MatchDetail {
  inputToken: string | null;
  matchedKeyword: string;
  matchType: "exact" | "concept" | "synonym";
  similarity: number;
}

interface MatchCandidate {
  keyword: string;
  componentSet: keyof typeof ICON_COMPONENT_SET_KEYS;
  variant: VariantProperty;
  score: number;
  detail: MatchDetail;
}

interface AssetGroup {
  keyword: string;
  position: number;
  assets: {
    componentSet: keyof typeof ICON_COMPONENT_SET_KEYS;
    variant: VariantProperty;
  }[];
}

type AssetCombination = {
  componentSet: keyof typeof ICON_COMPONENT_SET_KEYS;
  variant: VariantProperty;
}[];

interface MissingKeywordSuggestion {
  missing: string;
  related_keywords: Array<{
    keyword: string;
    similarity: number;
  }>;
}

interface SuggestionResult {
  keywords: string[];
  asset_properties: { componentSet: keyof typeof ICON_COMPONENT_SET_KEYS; variant: VariantProperty }[];
  asset_combinations: AssetCombination[];
  confidence_score: number;
  input_keywords: string[];
  missing_keywords: string[];
  missing_keyword_suggestions: MissingKeywordSuggestion[];
  match_details: MatchDetail[];
}

const DEFAULT_ICON_SIZE = 320;

// -----------------------------------------------------------
// 2. Figma ì»´í¬ë„ŒíŠ¸ ê´€ë¦¬ ë° ìºì‹±
// -----------------------------------------------------------

const componentSetCache = new Map<string, ComponentSetNode | null>();
const componentCache = new Map<string, ComponentNode | null>();

async function getComponentSet(setName: keyof typeof ICON_COMPONENT_SET_KEYS): Promise<ComponentSetNode | null> {
  if (componentSetCache.has(setName)) {
    return componentSetCache.get(setName)!;
  }

  const componentKey = ICON_COMPONENT_SET_KEYS[setName];
  if (!componentKey) {
    figma.notify(`'${setName}'ì— ëŒ€í•œ Component Set í‚¤ê°€ ICON_COMPONENT_SET_KEYSì— ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`, { error: true });
    componentSetCache.set(setName, null);
    return null;
  }

  console.log(`ğŸ” Component Set '${setName}' ë¡œë”© ì‹œë„... (í‚¤: ${componentKey})`);

  try {
    // importComponentSetByKeyAsyncë¥¼ ì‚¬ìš©í•˜ì—¬ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì»´í¬ë„ŒíŠ¸ ë¡œë“œ
    const node = await figma.importComponentSetByKeyAsync(componentKey);

    if (node && node.type === "COMPONENT_SET") {
      console.log(`âœ… Component Set '${setName}' ë¡œë“œ ì„±ê³µ`);

      // ğŸ” ë””ë²„ê¹…: ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  variant ì¶œë ¥
      console.log(`ğŸ“‹ Component Set '${setName}'ì˜ ì‚¬ìš© ê°€ëŠ¥í•œ variants:`);
      let variantIndex = 1;
      for (const child of node.children) {
        if (child.type === "COMPONENT") {
          console.log(`  ${variantIndex}. ${child.name}`, child.variantProperties);
          variantIndex++;
        }
      }

      componentSetCache.set(setName, node);
      return node;
    } else {
      console.error(`âŒ ë¡œë“œëœ ë…¸ë“œê°€ COMPONENT_SETì´ ì•„ë‹™ë‹ˆë‹¤:`, node?.type);
      figma.notify(`'${setName}' Component Setì„ ì°¾ì„ ìˆ˜ ì—†ê±°ë‚˜ íƒ€ì…ì´ ë‹¤ë¦…ë‹ˆë‹¤.`, { error: true });
      componentSetCache.set(setName, null);
      return null;
    }
  } catch (error) {
    console.error(`âŒ Component Set '${setName}' ë¡œë“œ ì¤‘ ì˜¤ë¥˜:`, error);
    console.error(`ì‚¬ìš©í•œ í‚¤: ${componentKey}`);
    figma.notify(`'${setName}' Component Set ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. í‚¤ê°€ ìœ íš¨í•œì§€ í™•ì¸í•˜ì„¸ìš”.`, { error: true });
    componentSetCache.set(setName, null);
    return null;
  }
}

function findVariant(
  componentSet: ComponentSetNode,
  properties: VariantProperty
): ComponentNode | null {
  const cacheKey = `${componentSet.id}:${JSON.stringify(properties)}`;
  if (componentCache.has(cacheKey)) {
    return componentCache.get(cacheKey) ?? null;
  }

  const variant = componentSet.findOne((node) => {
    if (node.type !== "COMPONENT") return false;
    if (!node.variantProperties) return false;

    // Check all requested properties against the node's properties
    return Object.entries(properties).every(([reqKey, reqValue]) => {
      // 1. Find matching key in node properties (case-insensitive)
      const nodeKey = Object.keys(node.variantProperties!).find(
        k => k.toLowerCase() === reqKey.toLowerCase()
      );
      if (!nodeKey) return false; // Key not found

      // 2. Compare values (case-insensitive)
      const nodeValue = node.variantProperties![nodeKey];
      return nodeValue.toLowerCase() === reqValue.toLowerCase();
    });
  }) as ComponentNode | null;

  componentCache.set(cacheKey, variant);
  return variant;
}

async function getComponentNode(setName: keyof typeof ICON_COMPONENT_SET_KEYS, properties: VariantProperty): Promise<ComponentNode | null> {
  const componentSet = await getComponentSet(setName);
  if (!componentSet) return null;
  return findVariant(componentSet, properties);
}

async function isAssetAvailable(setName: keyof typeof ICON_COMPONENT_SET_KEYS, properties: VariantProperty): Promise<boolean> {
  const component = await getComponentNode(setName, properties);
  return Boolean(component);
}

// -----------------------------------------------------------
// 3. ì‚¬ìš©ì ì •ì˜ ì•„ì´ì½˜ ë°ì´í„° ê´€ë¦¬ (Figma pluginData)
// -----------------------------------------------------------

const PLUGIN_DATA_KEY = "customIconDatabase";

/**
 * Figma íŒŒì¼ì—ì„œ ì‚¬ìš©ì ì •ì˜ ì•„ì´ì½˜ ë°ì´í„° ë¡œë“œ
 */
function loadCustomIconData(): CustomIconDatabase {
  try {
    const data = figma.root.getPluginData(PLUGIN_DATA_KEY);
    if (!data) {
      return { version: "1.0", lastUpdated: new Date().toISOString(), entries: [] };
    }
    return JSON.parse(data);
  } catch (error) {
    console.error("âŒ ì»¤ìŠ¤í…€ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
    return { version: "1.0", lastUpdated: new Date().toISOString(), entries: [] };
  }
}

/**
 * Figma íŒŒì¼ì— ì‚¬ìš©ì ì •ì˜ ì•„ì´ì½˜ ë°ì´í„° ì €ì¥
 */
function saveCustomIconData(database: CustomIconDatabase): void {
  try {
    database.lastUpdated = new Date().toISOString();
    figma.root.setPluginData(PLUGIN_DATA_KEY, JSON.stringify(database));
    console.log("âœ… ì»¤ìŠ¤í…€ ë°ì´í„° ì €ì¥ ì™„ë£Œ:", database.entries.length, "ê°œ í•­ëª©");
  } catch (error) {
    console.error("âŒ ì»¤ìŠ¤í…€ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:", error);
    throw error;
  }
}

/**
 * ê¸°ë³¸ icon-db.tsì™€ ì‚¬ìš©ì ì •ì˜ ë°ì´í„°ë¥¼ ë³‘í•©
 */
function getMergedIconData(): IconData {
  const customDB = loadCustomIconData();
  const merged: IconData = { ...iconData }; // ê¸°ë³¸ DB ë³µì‚¬

  // ì»¤ìŠ¤í…€ ë°ì´í„° ë³‘í•©
  for (const entry of customDB.entries) {
    // Component Setì´ ICON_COMPONENT_SET_KEYSì— ì—†ìœ¼ë©´ ë™ì  ì¶”ê°€
    if (!ICON_COMPONENT_SET_KEYS[entry.componentSetName]) {
      (ICON_COMPONENT_SET_KEYS as any)[entry.componentSetName] = entry.componentSetKey;
    }

    // í‚¤ì›Œë“œê°€ ì´ë¯¸ ì¡´ì¬í•˜ë©´ variants ë³‘í•©, ì—†ìœ¼ë©´ ìƒˆë¡œ ì¶”ê°€
    if (merged[entry.keyword]) {
      merged[entry.keyword].variants.push(...entry.variants);
    } else {
      merged[entry.keyword] = {
        description: entry.description,
        concept: entry.concept,
        componentSet: entry.componentSetName as keyof typeof ICON_COMPONENT_SET_KEYS,
        variants: entry.variants,
      };
    }
  }

  return merged;
}

// -----------------------------------------------------------
// 4. ë¡œì»¬ ë§¤í•‘ ê¸°ë°˜ ì•„ì´ì½˜ ì¶”ì²œ ë¡œì§
// -----------------------------------------------------------

function normalizeMenuName(menuName: string): string {
  return menuName.replace(/[^ê°€-í£a-zA-Z0-9]/g, "").toLowerCase();
}

function extractInputKeywords(menuName: string): string[] {
  const normalized = normalizeMenuName(menuName);
  const keywords = new Set<string>();
  const mergedData = getMergedIconData();
  for (const keyword of Object.keys(mergedData)) {
    const keywordNormalized = normalizeMenuName(keyword);
    if (!keywordNormalized) continue;
    if (normalized.includes(keywordNormalized)) {
      keywords.add(keyword);
    }
  }
  return Array.from(keywords);
}

// ... (Helper functions: identifyMissingKeywords, findRelatedKeywords, buildMissingKeywordSuggestions, getBigrams, getSimilarityScore, tokenizeConcept)
// ì´ í•¨ìˆ˜ë“¤ì€ í‚¤ì›Œë“œ ë§¤ì¹­ì—ë§Œ ê´€ì—¬í•˜ë¯€ë¡œ ìˆ˜ì •ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤. (ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼)
function identifyMissingKeywords(
  menuName: string,
  matchedKeywords: string[]
): string[] {
  const normalized = normalizeMenuName(menuName);
  if (!normalized) return [];

  let residual = normalized;
  const sortedMatched = matchedKeywords
    .map((keyword) => normalizeMenuName(keyword))
    .filter(Boolean)
    .sort((a, b) => b.length - a.length);

  for (const keyword of sortedMatched) {
    residual = residual.split(keyword).join(" ");
  }

  const tokens =
    residual
      .split(/[^ê°€-í£a-zA-Z0-9]+/g)
      .map((token) => token.trim())
      .filter((token) => token.length >= 2) ?? [];

  return Array.from(new Set(tokens));
}

function findRelatedKeywords(
  token: string,
  limit = 3
): MissingKeywordSuggestion["related_keywords"] {
  const normalizedToken = normalizeMenuName(token);
  if (!normalizedToken) return [];

  const scored: MissingKeywordSuggestion["related_keywords"] = [];

  for (const keyword in iconData) {
    const definition = iconData[keyword];
    if (!definition) continue; // ì •ì˜ê°€ ì—†ìœ¼ë©´ ê±´ë„ˆëœ€

    const keywordNormalized = normalizeMenuName(keyword);
    let bestScore = 0;

    if (keywordNormalized) {
      if (
        normalizedToken.includes(keywordNormalized) ||
        keywordNormalized.includes(normalizedToken)
      ) {
        bestScore = Math.max(bestScore, 0.7);
      }
      bestScore = Math.max(
        bestScore,
        getSimilarityScore(normalizedToken, keywordNormalized)
      );
    }

    const representativeConcept = definition.concept; // IconDefinitionì˜ concept ì†ì„± ì§ì ‘ ì ‘ê·¼
    for (const conceptToken of tokenizeConcept(representativeConcept)) {
      const conceptNormalized = normalizeMenuName(conceptToken);
      if (!conceptNormalized) continue;
      if (
        normalizedToken.includes(conceptNormalized) ||
        conceptNormalized.includes(normalizedToken)
      ) {
        bestScore = Math.max(bestScore, 0.6);
      }
      bestScore = Math.max(
        bestScore,
        getSimilarityScore(normalizedToken, conceptNormalized)
      );
    }

    if (bestScore >= 0.25) {
      scored.push({
        keyword: keyword,
        similarity: Number(bestScore.toFixed(2)),
      });
    }
  }

  scored.sort(
    (a, b) => b.similarity - a.similarity || a.keyword.localeCompare(b.keyword)
  );

  return scored.slice(0, limit);
}

function buildMissingKeywordSuggestions(
  menuName: string,
  matchedKeywords: string[]
): MissingKeywordSuggestion[] {
  const missing = identifyMissingKeywords(menuName, matchedKeywords);
  return missing.map((token) => ({
    missing: token,
    related_keywords: findRelatedKeywords(token),
  }));
}

function getBigrams(text: string): string[] {
  if (!text) return [];
  if (text.length === 1) return [text];
  const grams: string[] = [];
  for (let i = 0; i < text.length - 1; i += 1) {
    grams.push(text.slice(i, i + 2));
  }
  return grams;
}

function getSimilarityScore(source: string, target: string): number {
  const sourceNorm = normalizeMenuName(source);
  const targetNorm = normalizeMenuName(target);
  const gramsA = getBigrams(sourceNorm);
  const gramsB = getBigrams(targetNorm);
  if (gramsA.length === 0 || gramsB.length === 0) {
    return 0;
  }
  const setA = new Set(gramsA);
  const setB = new Set(gramsB);
  let intersection = 0;
  for (const gram of setA) {
    if (setB.has(gram)) {
      intersection += 1;
    }
  }
  const union = setA.size + setB.size - intersection;
  return union === 0 ? 0 : intersection / union;
}

function tokenizeConcept(concept: string): string[] {
  return concept
    .split(",")
    .map((token) => token.trim().toLowerCase().replace(/\s+/g, ""))
    .filter(Boolean);
}


function findMatchCandidates(menuName: string): MatchCandidate[] {
  const normalized = normalizeMenuName(menuName);
  const candidates: MatchCandidate[] = [];
  const mergedData = getMergedIconData();

  for (const keyword in mergedData) {
    const definition = mergedData[keyword]; // This is a single IconDefinition
    if (!definition) continue;

    const keywordNormalized = normalizeMenuName(keyword);
    let bestScore = 0;
    let bestDetail: MatchDetail | null = null;

    // 1. í‚¤ì›Œë“œ ì§ì ‘ ì¼ì¹˜ ì ìˆ˜ ê³„ì‚°
    if (keywordNormalized && normalized.includes(keywordNormalized)) {
      bestScore = 1;
      bestDetail = { inputToken: keyword, matchedKeyword: keyword, matchType: "exact", similarity: 1 };
    } else if (keywordNormalized) {
      const similarity = getSimilarityScore(normalized, keywordNormalized);
      if (similarity > bestScore) {
        bestScore = similarity;
        bestDetail = { inputToken: null, matchedKeyword: keyword, matchType: "synonym", similarity };
      }
    }

    // 2. ì»¨ì…‰(ë™ì˜ì–´) ì¼ì¹˜ ì ìˆ˜ ê³„ì‚°
    const representativeConcept = definition.concept;
    const conceptTokens = tokenizeConcept(representativeConcept);
    for (const token of conceptTokens) {
      if (normalized.includes(token)) {
        const conceptScore = 0.9;
        if (conceptScore > bestScore) {
          bestScore = conceptScore;
          bestDetail = { inputToken: token, matchedKeyword: keyword, matchType: "concept", similarity: conceptScore };
        }
      } else {
        const similarity = getSimilarityScore(normalized, token);
        if (similarity > bestScore) {
          bestScore = similarity;
          bestDetail = { inputToken: token, matchedKeyword: keyword, matchType: "synonym", similarity };
        }
      }
    }

    // 3. ì ìˆ˜ê°€ ê¸°ì¤€ ì´ìƒì´ë©´ ê° variantì— ëŒ€í•´ í›„ë³´ ìƒì„±
    if (bestDetail && bestScore >= 0.35) {
      for (const variant of definition.variants) {
        candidates.push({
          keyword: keyword,
          componentSet: definition.componentSet,
          variant: variant,
          score: bestScore,
          detail: {
            ...bestDetail,
            similarity: Number(bestScore.toFixed(2)),
          },
        });
      }
    }
  }

  return candidates.sort((a, b) => b.score - a.score);
}

// getKeywordPosition and buildKeywordAssetGroups have been removed.

// computeAssetCombinations removed in favor of buildLayeredCombinations

// ğŸ†• ë³€ê²½ëœ ë¡œì§: ë ˆì´ì–´ ê¸°ë°˜ ì¡°í•© ìƒì„±
// -----------------------------------------------------------
// Helper: í‚¤ì›Œë“œ ìœ„ì¹˜ ì°¾ê¸°
function getKeywordPosition(menuName: string, keyword: string): number {
  const index = menuName.indexOf(keyword);
  return index >= 0 ? index : -1;
}

// -----------------------------------------------------------
// 1. í‚¤ì›Œë“œë³„ ì—ì…‹ ê·¸ë£¹í™” (detected sequence respecting)
async function buildKeywordAssetGroups(menuName: string, candidates: MatchCandidate[]): Promise<AssetGroup[]> {
  const groupsByKeyword: { [key: string]: AssetGroup } = {};

  // Fetch needed component sets
  const neededSetNames = new Set(candidates.map(c => c.componentSet));
  await Promise.all(Array.from(neededSetNames).map(setName => getComponentSet(setName)));

  for (const candidate of candidates) {
    if (await isAssetAvailable(candidate.componentSet, candidate.variant)) {
      if (!groupsByKeyword[candidate.keyword]) {
        groupsByKeyword[candidate.keyword] = {
          keyword: candidate.keyword,
          position: getKeywordPosition(menuName, candidate.keyword),
          assets: [],
        };
      }
      groupsByKeyword[candidate.keyword].assets.push({
        componentSet: candidate.componentSet,
        variant: candidate.variant,
      });
    }
  }

  const groups = Object.values(groupsByKeyword);

  // Sort groups by keyword position in the input string
  groups.sort((a, b) => {
    const posA = a.position >= 0 ? a.position : Number.MAX_SAFE_INTEGER;
    const posB = b.position >= 0 ? b.position : Number.MAX_SAFE_INTEGER;
    if (posA === posB) return a.keyword.localeCompare(b.keyword);
    return posA - posB;
  });

  return groups;
}

// -----------------------------------------------------------
// 2. ë ˆì´ì–´ ì¶©ëŒ ê°ì§€
function hasLayerConflict(combo: { componentSet: keyof typeof ICON_COMPONENT_SET_KEYS; variant: VariantProperty }[]): boolean {
  const seenLayers = new Set<LayerType>();

  for (const asset of combo) {
    const type = getLayerType(asset.variant);
    if (type) {
      if (seenLayers.has(type)) return true;
      seenLayers.add(type);
    }
  }
  return false;
}

// -----------------------------------------------------------
// 3. ì¡°í•© ìƒì„± (Cartesian Product with Layer Conflict Check)
function computeAssetCombinations(groups: AssetGroup[]): AssetCombination[] {
  if (groups.length === 0) return [];

  // Start with empty combinations [ [] ]
  let combinations: AssetCombination[] = [[]];

  for (const group of groups) {
    const nextCombinations: AssetCombination[] = [];

    // Try to append each asset from the current group to existing combinations
    for (const baseCombo of combinations) {
      for (const asset of group.assets) {
        const newCombo = [...baseCombo, asset];

        // Critical: Check if adding this asset causes a layer conflict
        if (hasLayerConflict(newCombo)) {
          continue;
        }

        nextCombinations.push(newCombo);
      }
    }

    // If we detected valid combinations including this keyword, proceed with them.
    // If not, it means this keyword cannot be added to ANY existing path without conflict.
    // In that case, we stick to the 'combinations' we had so far (partial match), 
    // OR we strictly break. 
    // The reference logic effectively stops or filters.
    // We will update 'combinations' only if we found valid next steps.
    if (nextCombinations.length > 0) {
      combinations = nextCombinations;
    }
    // If nextCombinations is empty, we just skip this keyword and keep previous 'valid' combos.
    // This allows "Code(Manage) + Manage(Skip)" -> Result: Code.
    // Wait, the user wants "Code + Manage". If Manage conflicts, maybe we should try "Manage" as base?
    // But keyword order matters.
  }

  return combinations;
}

async function getLocalIconSuggestion(menuName: string): Promise<SuggestionResult> {
  const candidates = findMatchCandidates(menuName);

  // Deduplicate keywords and details for reporting
  const uniqueKeywords = Array.from(new Set(candidates.map(c => c.keyword)));
  const matchDetails = Object.values(candidates.reduce((acc, c) => {
    acc[c.detail.matchedKeyword] = c.detail;
    return acc;
  }, {} as { [key: string]: MatchDetail }));

  const inputKeywords = extractInputKeywords(menuName);
  const missingKeywordSuggestions = buildMissingKeywordSuggestions(menuName, uniqueKeywords);
  const missingKeywords = missingKeywordSuggestions.map(item => item.missing);

  // ğŸ”„ REPLACED LOGIC: Keyword-centric stacking
  const groups = await buildKeywordAssetGroups(menuName, candidates);
  let combinations = computeAssetCombinations(groups);

  // Fallback: If no combinations, try detecting single assets
  if (combinations.length === 0 || (combinations.length === 1 && combinations[0].length === 0)) {
    combinations = candidates.map(c => ([{
      componentSet: c.componentSet,
      variant: c.variant
    }]));
  }

  // Deduplicate combinations
  const uniqueCombos = new Set<string>();
  combinations = combinations.filter(combo => {
    if (combo.length === 0) return false;
    const key = JSON.stringify(combo);
    if (uniqueCombos.has(key)) return false;
    uniqueCombos.add(key);
    return true;
  });

  const flattenedAssets = combinations.flat();
  const uniqueAssetProperties = Array.from(new Set(flattenedAssets.map(p => JSON.stringify(p)))).map(s => JSON.parse(s));

  const confidence = candidates.length > 0 ? Math.min(1, 0.5 + uniqueKeywords.length * 0.2) : 0.2;

  return {
    keywords: uniqueKeywords,
    asset_properties: uniqueAssetProperties,
    asset_combinations: combinations,
    confidence_score: Number(confidence.toFixed(2)),
    input_keywords: inputKeywords,
    missing_keywords: missingKeywords,
    missing_keyword_suggestions: missingKeywordSuggestions,
    match_details: matchDetails,
  };
}

// -----------------------------------------------------------
// 4. Figma UI í†µì‹  ë° ì»´í¬ë„ŒíŠ¸ ë°°ì¹˜
// -----------------------------------------------------------

figma.ui.onmessage = async (msg) => {
  if (msg.type === "suggest-icons") {
    const menuName: string = msg.menuName?.toString() ?? "";
    try {
      const result = await getLocalIconSuggestion(menuName);
      figma.ui.postMessage({ type: "suggestions-result", result });
      await placeIconCombinations(result.asset_combinations, menuName);
    } catch (error) {
      console.error(error);
      const errorMessage = error instanceof Error ? error.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
      figma.ui.postMessage({ type: "suggestions-error", message: errorMessage });
    }
  }


  // Component Set ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  else if (msg.type === "get-selected-component-set") {
    const selection = figma.currentPage.selection;
    if (selection.length === 1 && selection[0].type === "COMPONENT_SET") {
      const componentSet = selection[0] as ComponentSetNode;
      figma.ui.postMessage({
        type: "component-set-info",
        data: {
          name: componentSet.name,
          key: componentSet.key,
          variants: componentSet.children
            .filter(child => child.type === "COMPONENT")
            .map(child => (child as ComponentNode).variantProperties)
        }
      });
    } else {
      figma.notify("Component Setì„ ì„ íƒí•´ì£¼ì„¸ìš”", { error: true });
    }
  }

  // Google Sheets ë™ê¸°í™” (ì™¸ë¶€ DB)
  else if (msg.type === "sync-external-db") {
    try {
      const externalData: any[] = msg.data;
      if (!Array.isArray(externalData)) throw new Error("ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");

      const customDB = loadCustomIconData();
      let addedCount = 0;

      // ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ ë° ì •ì œ
      const newEntries: CustomIconEntry[] = externalData
        .filter(item => item.keyword && item.componentSetKey && item.componentSetName)
        .map(item => ({
          keyword: item.keyword,
          description: item.description || "",
          concept: item.concept || "",
          componentSetKey: item.componentSetKey,
          componentSetName: item.componentSetName,
          variants: Array.isArray(item.variants) ? item.variants : [],
          createdAt: new Date().toISOString(),
        }));

      if (newEntries.length === 0) {
        // ë””ë²„ê¹…ì„ ìœ„í•œ ìƒì„¸ ì—ëŸ¬ ë©”ì‹œì§€ ìƒì„±
        let debugMsg = "ìœ íš¨í•œ ë°ì´í„°ê°€ 0ê°œì…ë‹ˆë‹¤.";
        if (externalData.length > 0) {
          const firstItem = externalData[0];
          const keys = Object.keys(firstItem).join(", ");
          debugMsg = `ë°ì´í„° í•„ë“œ ë¶ˆì¼ì¹˜.\në°›ì€ í•„ë“œ: [${keys}]\ní•„ìš”í•œ í•„ë“œ: keyword, componentSetKey, componentSetName`;
          console.error("Sync Data Mismatch:", firstItem);
        } else {
          debugMsg = "êµ¬ê¸€ ì‹œíŠ¸ì— ë°ì´í„° í–‰ì´ ì—†ìŠµë‹ˆë‹¤.";
        }
        throw new Error(debugMsg);
      }

      // ê¸°ì¡´ DBì— ì¶”ê°€ (ì¤‘ë³µ ì²´í¬ ì—†ì´ ì¶”ê°€ - ì¶”í›„ ê°œì„  ê°€ëŠ¥)
      customDB.entries.push(...newEntries);
      addedCount = newEntries.length;

      saveCustomIconData(customDB);

      if (!msg.silent) {
        figma.notify(`âœ… ${addedCount}ê°œì˜ ì—ì…‹ì„ ë™ê¸°í™”í–ˆìŠµë‹ˆë‹¤!`, { timeout: 3000 });
        figma.ui.postMessage({ type: "register-success", keyword: `${addedCount}ê°œ í•­ëª©` }); // UI ì—…ë°ì´íŠ¸ìš©
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : "ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ";
      figma.notify(`âŒ ë™ê¸°í™” ì‹¤íŒ¨: ${errorMsg}`, { error: true });
    }
  }
};

async function createFallbackFrame(componentName: string): Promise<FrameNode> {
  const fallbackFrame = figma.createFrame();
  fallbackFrame.name = componentName;
  fallbackFrame.resize(DEFAULT_ICON_SIZE, DEFAULT_ICON_SIZE);
  fallbackFrame.fills = [{ type: 'SOLID', color: { r: 0.9, g: 0.9, b: 0.9 } }];
  fallbackFrame.cornerRadius = 8;

  await figma.loadFontAsync({ family: "Inter", style: "Regular" });
  const text = figma.createText();
  text.characters = "Missing\n" + componentName;
  text.fontSize = 10;
  text.textAlignHorizontal = "CENTER";
  text.textAlignVertical = "CENTER";
  text.resize(DEFAULT_ICON_SIZE, DEFAULT_ICON_SIZE);

  fallbackFrame.appendChild(text);
  return fallbackFrame;
}

async function createIconInstance(setName: keyof typeof ICON_COMPONENT_SET_KEYS, properties: VariantProperty, assetName: string): Promise<SceneNode> {
  const componentNode = await getComponentNode(setName, properties);

  if (componentNode) {
    const instance = componentNode.createInstance();
    instance.name = assetName;
    return instance;
  }

  console.log(`Fallback for ${assetName}`);
  return createFallbackFrame(assetName);
}

async function placeIconCombinations(assetCombos: AssetCombination[], menuName: string): Promise<void> {
  if (assetCombos.length === 0) {
    figma.notify("ë§¤í•‘ëœ ì•„ì´ì½˜ ì¡°í•©ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.", { timeout: 3000 });
    return;
  }

  const selection = figma.currentPage.selection;
  const startX = selection.length > 0 ? selection[0].x + selection[0].width + 100 : 100;
  const startY = selection.length > 0 ? selection[0].y : 100;

  const suggestionFrame = figma.createFrame();
  suggestionFrame.name = `ğŸ’¡ ${menuName} ì•„ì´ì½˜ ì œì•ˆ`;
  suggestionFrame.layoutMode = "VERTICAL";
  suggestionFrame.layoutSizingHorizontal = "HUG";
  suggestionFrame.layoutSizingVertical = "HUG";
  suggestionFrame.paddingTop = suggestionFrame.paddingRight = suggestionFrame.paddingBottom = suggestionFrame.paddingLeft = 24;
  suggestionFrame.itemSpacing = 40;
  suggestionFrame.fills = [{ type: "SOLID", color: { r: 1, g: 1, b: 1 } }];
  suggestionFrame.cornerRadius = 10;
  suggestionFrame.x = startX;
  suggestionFrame.y = startY;

  figma.currentPage.appendChild(suggestionFrame);
  figma.notify(`Figma ìº”ë²„ìŠ¤ì— ${assetCombos.length}ê°œì˜ ì•„ì´ì½˜ ì¡°í•©ì„ ë°°ì¹˜í•©ë‹ˆë‹¤.`, { timeout: 2000 });

  // Define a layer order if needed for stacking
  // const layerOrder = ['bg', 'metaphor', 'badge_1'];

  for (const [index, combo] of assetCombos.entries()) {
    try {
      const comboFrame = figma.createFrame();
      comboFrame.name = `Option ${index + 1}`;
      // ... (combo frame setup)
      comboFrame.layoutMode = "VERTICAL";
      comboFrame.layoutSizingHorizontal = "HUG";
      comboFrame.layoutSizingVertical = "HUG";
      comboFrame.primaryAxisAlignItems = "CENTER";
      comboFrame.counterAxisAlignItems = "CENTER";
      comboFrame.itemSpacing = 12;
      comboFrame.fills = [];

      const stackFrame = figma.createFrame();
      stackFrame.name = `Stack ${index + 1}`;
      stackFrame.resize(DEFAULT_ICON_SIZE, DEFAULT_ICON_SIZE);
      stackFrame.clipsContent = true;
      stackFrame.fills = [];

      // ğŸ¨ ë ˆì´ì–´ ìˆœì„œëŒ€ë¡œ ì •ë ¬ (bg â†’ metaphor â†’ badge_1)
      const sortedCombo = combo.slice().sort((a, b) => {
        const layerA = getLayerType(a.variant);
        const layerB = getLayerType(b.variant);

        // ë ˆì´ì–´ íƒ€ì…ì´ ì—†ëŠ” ê²½ìš° ë§¨ ìœ„ë¡œ
        if (!layerA && !layerB) return 0;
        if (!layerA) return 1;
        if (!layerB) return -1;

        // z-index ìˆœì„œëŒ€ë¡œ ì •ë ¬ (ë‚®ì€ ìˆ«ìê°€ ë¨¼ì € = ì•„ë˜ ë ˆì´ì–´)
        return LAYER_Z_INDEX[layerA] - LAYER_Z_INDEX[layerB];
      });

      console.log(`ğŸ“ ì¡°í•© ${index + 1} ë ˆì´ì–´ ìˆœì„œ:`, sortedCombo.map(a => {
        const layer = getLayerType(a.variant);
        return `${layer} (z:${layer ? LAYER_Z_INDEX[layer] : '?'})`;
      }).join(' â†’ '));

      for (const asset of sortedCombo) {
        // Construct a descriptive name for the instance
        const assetName = Object.values(asset.variant).join('-');
        const instance = await createIconInstance(asset.componentSet, asset.variant, assetName);

        if (instance.type === "INSTANCE") {
          instance.resize(DEFAULT_ICON_SIZE, DEFAULT_ICON_SIZE);
        }
        instance.x = 0;
        instance.y = 0;
        stackFrame.appendChild(instance);
      }

      await figma.loadFontAsync({ family: "Inter", style: "Regular" });
      const label = figma.createText();
      label.characters = combo.map(p => Object.values(p.variant).join('-')).join(" + ");
      // ... (label setup)
      label.fontSize = 14;
      label.fills = [{ type: "SOLID", color: { r: 0.3, g: 0.3, b: 0.3 } }];

      comboFrame.appendChild(stackFrame);
      comboFrame.appendChild(label);
      suggestionFrame.appendChild(comboFrame);
    } catch (error) {
      console.error(`ì•„ì´ì½˜ ë°°ì¹˜ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (ì¡°í•© ${index + 1})`, error);
      figma.notify(`ì•„ì´ì½˜ ì¡°í•© ${index + 1} ë°°ì¹˜ ì‹¤íŒ¨. ì½˜ì†” í™•ì¸.`, { timeout: 3000 });
    }
  }

  figma.currentPage.selection = [suggestionFrame];
  figma.viewport.scrollAndZoomIntoView([suggestionFrame]);
}
