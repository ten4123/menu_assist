# Figma 플러그인 개발 모범 사례 가이드

이 문서는 `menu_assist` 플러그인 프로젝트의 설정과 코드베이스를 Figma 공식 문서와 비교하여 분석한 결과를 바탕으로 작성되었습니다. 앞으로의 유지보수 및 기능 개발 시 지침으로 활용할 수 있습니다.

---

## 1. 프로젝트 설정 및 구성 (`manifest.json`)

`manifest.json` 파일은 플러그인의 명세서와 같습니다. 현재 우리 프로젝트의 설정은 표준을 잘 따르고 있습니다.

- **핵심 필드:**
  - `name`: 플러그인의 이름입니다.
  - `main`: 플러그인 로직이 담긴 **컴파일된** JavaScript 파일 경로입니다. (`code.js`)
  - `ui`: 플러그인 UI를 정의한 HTML 파일 경로입니다. (`ui.html`)
  - `editorType`: 플러그인이 실행될 환경을 지정합니다. (현재 `"figma"`로 올바르게 설정됨)

- **주요 권장 사항:**
  - **`networkAccess` (네트워크 접근):** 현재 `{"allowedDomains": ["none"]}`으로 설정되어 있습니다. 이는 보안상 좋은 초기 설정이며, 플러그인이 외부 API와 통신할 필요가 없음을 명확히 합니다. 만약 향후 외부 API 연동이 필요하다면, 이 부분에 해당 도메인을 명시적으로 추가해야 합니다.
  - **`documentAccess` (문서 접근):** 현재 `dynamic-page`로 설정되어 있습니다. 이는 플러그인이 현재 사용자가 보고 있는 페이지의 노드에만 접근할 수 있도록 제한하는 보안 강화 설정입니다. 이로 인해 `figma.getNodeById()` 사용에 제약이 생길 수 있지만, 현재 코드처럼 `figma.currentPage.findOne()` 등으로 우회하여 기능을 구현하는 것은 유효한 방식입니다.

---

## 2. 플러그인 아키텍처 (실행 방식)

Figma 플러그인은 두 개의 분리된 환경(스레드)에서 실행됩니다.

1.  **메인 스레드 (Main Thread):**
    - **파일:** `code.ts`
    - **역할:** Figma 문서의 노드를 생성, 수정, 삭제하는 등 파일에 직접적인 변경을 가하는 모든 로직을 처리합니다. Figma API의 대부분은 이 스레드에서만 접근 가능합니다.
    - **특징:** DOM 접근이 불가능하여 시각적인 UI를 직접 그릴 수 없습니다.

2.  **UI 스레드 (UI Thread):**
    - **파일:** `ui.html` (및 여기에 포함된 `<script>` 태그 안의 JavaScript)
    - **역할:** 사용자가 보게 될 UI(버튼, 입력창 등)를 렌더링하고 사용자 인터랙션을 처리합니다.
    - **특징:** Figma 문서에 직접 접근할 수 없습니다.

- **스레드 간 통신:**
  - **UI → 메인:** `parent.postMessage({ pluginMessage: { ... } }, '*')`
  - **메인 → UI:** `figma.ui.postMessage({ ... })`
  - 우리 프로젝트의 `code.ts`는 `figma.ui.onmessage`를 통해 UI로부터 메시지를 받아 처리하고 있으며, 이는 표준적인 통신 방식을 정확히 따르고 있습니다.

---

## 3. Figma 노드 접근 및 수정 (핵심 로직)

Figma 문서의 모든 요소(프레임, 텍스트, 컴포넌트 등)는 '노드(Node)'입니다.

- **노드 검색:**
  - `figma.currentPage.selection`: 사용자가 현재 선택한 노드의 배열입니다.
  - `figma.currentPage.findOne(predicate)`: 현재 페이지에서 조건(predicate)에 맞는 첫 번째 노드를 찾습니다.
  - `figma.currentPage.findAll(predicate)`: 조건에 맞는 모든 노드를 찾습니다.

- **현재 프로젝트의 방식 및 권장 사항:**
  - 우리 코드는 `findOne`과 `node.name.includes(...)`를 조합하여 이름으로 컴포넌트를 찾고 있습니다.
  - **장점:** 구현이 직관적이고 빠릅니다.
  - **잠재적 위험:** 컴포넌트 이름이 변경되거나 유사한 이름의 컴포넌트가 생기면 오작동의 원인이 될 수 있습니다.
  - **장기적 권장 사항:** 플러그인이 복잡해지거나 외부 라이브러리 컴포넌트를 사용하게 될 경우, 이름 대신 `key` 값을 이용하는 `figma.importComponentByKeyAsync()` 방식이 훨씬 안정적입니다. 하지만 현재로서는 "컴포넌트 이름의 정확성"을 유지하는 것이 중요합니다.

- **속성 수정:**
  - `.name`, `.x`, `.y` 와 같은 단순 속성은 직접 값을 할당하여 수정할 수 있습니다.
  - `.fills`, `.strokes` 와 같은 배열 기반의 복잡한 속성은 직접 수정이 불가능합니다. **배열의 복사본을 만들어 수정한 뒤, 그 복사본을 통째로 다시 할당해야 합니다.** 우리 코드는 이 패턴을 올바르게 사용하고 있습니다.

---

## 4. 비동기 작업 (`async/await`)

Figma API의 많은 함수들, 특히 문서를 변경하거나 폰트/이미지를 불러오는 작업들은 비동기(asynchronous)로 동작합니다.

- **핵심:** 비동기 함수는 `Promise`를 반환하며, 반드시 `async/await` 구문을 사용하여 결과를 기다려야 합니다. 이를 지키지 않으면 코드가 예상치 못한 순서로 실행되어 오류를 발생시킵니다.
- **예시 (우리 코드):**
  ```typescript
  await figma.loadFontAsync({ family: "Inter", style: "Regular" });
  const instance = await createIconInstance(assetName);
  ```

---

## 5. 타입스크립트 활용

Figma는 타입스크립트 사용을 강력히 권장하며, 우리 프로젝트는 이를 잘 활용하고 있습니다.

- **핵심:** `@figma/plugin-typings` 패키지가 제공하는 타입을 적극적으로 사용해야 합니다.
- **장점:**
  - 코드 자동완성을 통해 사용 가능한 속성과 함수를 쉽게 찾을 수 있습니다.
  - 컴파일 시점에 타입 오류를 미리 발견하여 런타임 에러를 줄일 수 있습니다.
- **예시 (우리 코드):**
  ```typescript
  function getComponentNode(assetName: string): ComponentNode | null { ... }
  async function createFallbackFrame(componentName: string): Promise<FrameNode> { ... }
  ```
  위와 같이 함수의 인자와 반환 값에 정확한 타입을 명시하는 것이 매우 좋은 습관입니다.

---

## 6. 빌드 및 테스트 워크플로우

1.  **의존성 설치:** (필요시) `npm install`
2.  **코드 수정:** `code.ts`, `ui.html` 등 소스 파일 수정
3.  **빌드:** `npm run build` 명령어로 `code.ts`를 `code.js`로 컴파일
4.  **테스트:** Figma 데스크톱 앱에서 `Plugins > Development > [플러그인 이름]` 을 Reload 하거나 다시 Import 하여 테스트

---

## 7. UI 개발 및 테마 적용

플러그인의 UI는 웹 표준 기술(HTML, CSS, JavaScript)을 기반으로 `ui.html` 파일에서 제작됩니다.

- **UI 통신:** `2. 플러그인 아키텍처`에서 설명한 `postMessage` 방식을 사용하여 메인 스레드와 데이터를 주고받는 것은 올바르게 구현되어 있습니다.

- **UI 테마 적용 (중요 개선 사항):**
  - **현상:** 현재 우리 플러그인은 자체적으로 정의한 어두운 색상 테마를 사용하고 있어, 사용자가 Figma를 라이트 모드로 사용해도 UI가 어둡게 보입니다.
  - **권장 사항:** Figma의 네이티브 테마를 적용하여 사용자의 설정(라이트/다크 모드)에 따라 UI가 자동으로 변경되도록 개선해야 합니다. 이는 사용자 경험을 크게 향상시킵니다.
  - **적용 방법 (2단계):**
    1.  **`code.ts` 수정:** `figma.showUI`를 호출할 때 `themeColors: true` 옵션을 추가합니다.
        ```typescript
        // 기존 코드
        figma.showUI(__html__, { width: 360, height: 550, title: "아이콘 매핑 제안" });

        // 수정 후 코드
        figma.showUI(__html__, { width: 360, height: 550, title: "아이콘 매핑 제안", themeColors: true });
        ```
    2.  **`ui.html` 수정:** `<style>` 태그 안에서 직접 정의했던 `:root` 안의 모든 `--figma-color-...` 변수들을 삭제합니다. `themeColors: true` 옵션이 활성화되면 Figma가 자동으로 이 변수들을 주입해주기 때문입니다.

---

## 8. 빠른 입력을 위한 '플러그인 파라미터'

'플러그인 파라미터(Plugin Parameters)'는 별도의 UI 창을 열지 않고, Figma의 빠른 실행(Quick Actions) 창에서 직접 텍스트 등의 값을 입력받아 플러그인을 실행하는 기능입니다.

- **특징:**
  - 간단한 입력만 필요한 기능에 적합합니다. (예: 특정 이름으로 프레임 생성하기)
  - 복잡한 UI 없이 신속하게 기능을 실행할 수 있어 사용자 경험이 좋습니다.

- **프로젝트 적용성:**
  - 우리 플러그인은 메뉴명을 입력받고 여러 결과를 시각적으로 보여줘야 하므로 현재의 전체 UI 방식이 더 적합합니다.
  - 하지만, 만약 "키워드 하나로 기본 아이콘 바로 생성하기"와 같은 매우 단순한 기능을 추가하게 된다면, '플러그인 파라미터'는 훌륭한 대안이 될 수 있습니다. 향후 기능 확장 시 고려해볼 만한 옵션입니다.

---

## 9. 네트워크 요청 (외부 API 연동)

플러그인에서 외부 API를 호출해야 할 경우, 표준 `fetch` API를 사용합니다.

- **보안 설정:** `manifest.json` 파일의 `networkAccess` 필드에 접근을 허용할 도메인 목록을 명시적으로 선언해야 합니다.
  ```json
  "networkAccess": {
    "allowedDomains": [
      "https://api.example.com"
    ]
  }
  ```
- **현재 상태:** 우리 플러그인은 현재 외부 API를 사용하지 않으므로, 보안을 위해 `allowedDomains`가 `["none"]`으로 올바르게 설정되어 있습니다.

---

## 10. 고급 노드 조작

#### 10.1. 텍스트 다루기 (Text Nodes)

- **폰트 로딩:** 텍스트 노드의 내용을 변경하거나, 폰트 관련 속성을 수정하기 전에는 반드시 `await figma.loadFontAsync()`를 호출하여 폰트를 불러와야 합니다. 우리 코드는 이 규칙을 잘 따르고 있습니다.

- **리치 텍스트 (Rich Text):** 하나의 텍스트 노드 안에서 부분적으로 굵게, 기울임꼴, 링크 등을 적용할 수 있습니다. 이는 컴포넌트 설명이나 주석 같은 텍스트에 서식을 추가할 때 유용합니다. `descriptionMarkdown`과 같은 속성을 사용하여 Markdown 형식으로 서식을 적용할 수 있습니다.

#### 10.2. 이미지 다루기 (Image Fills)

플러그인은 외부에서 이미지를 가져와 Figma 노드의 채우기(fill)로 사용할 수 있습니다.

- **프로세스:**
  1.  UI 스레드(`ui.html`)에서 `fetch`를 사용해 이미지 데이터를 다운로드합니다.
  2.  이미지 데이터를 `Uint8Array` (바이트 배열) 형식으로 변환합니다.
  3.  `postMessage`를 통해 메인 스레드(`code.ts`)로 바이트 배열을 전달합니다.
  4.  메인 스레드에서 `figma.createImage(bytes)`를 호출하여 이미지 해시(Image hash)를 생성합니다.
  5.  이 이미지 해시를 사각형이나 프레임 등의 `fills` 속성에 `type: 'IMAGE'`와 함께 할당합니다.

- **프로젝트 적용성:** 현재는 기존 컴포넌트를 복제하는 방식이지만, 향후 외부 URL이나 사용자가 업로드한 이미지로 아이콘을 생성하는 기능을 추가할 때 이 방식을 활용할 수 있습니다.

#### 10.3. Figma 변수 (Variables)

'변수(Variables)'는 색상, 숫자, 텍스트값 등을 재사용 가능한 토큰으로 만들어 디자인 시스템을 관리하는 Figma의 강력한 기능입니다. 플러그인은 이 변수를 읽거나 노드 속성에 바인딩할 수 있습니다.

- **활용 방안:**
  - **색상 변수 적용:** 하드코딩된 색상값 대신 `figma.variables.getVariableById()`로 색상 변수를 찾아 노드의 `fills`에 바인딩할 수 있습니다. 이렇게 하면 디자인 시스템의 테마(예: 라이트/다크 모드)가 변경될 때 플러그인이 생성한 요소도 함께 색상이 변경됩니다.
  - **간격/크기 변수 적용:** 숫자 변수를 노드의 크기나 간격(`itemSpacing`) 등에 바인딩하여 일관된 레이아웃을 유지할 수 있습니다.
- **프로젝트 적용성:** 현재 플러그인은 하드코딩된 값(예: 프레임 크기, 색상)을 사용하지만, 향후 Figma 변수와 연동하면 훨씬 더 유연하고 통합된 결과물을 생성할 수 있습니다.

---

## 11. OAuth with Plugins

Figma 플러그인에서 OAuth를 구현하는 방법을 설명합니다. 표준 웹 또는 네이티브 앱 OAuth 흐름과 다르기 때문에 공개적으로 사용 가능한 HTTPS 서버가 필요합니다. 안전한 인증 흐름을 상세히 설명하고, PKCE(Proof Key for Code Exchange) 및 클라이언트 측 액세스 토큰 저장을 권장합니다.

## 12. Debugging

"Plugins > Development > Open Console..." 또는 ⌥⌘I를 통해 접근할 수 있는 개발자 도구 패널을 사용하여 Figma 플러그인을 디버그하는 방법을 설명합니다. 플러그인 API를 탐색하고, `console.log()`로 변수 값을 출력하며, 브라우저의 JavaScript 엔진에서 디버깅하기 위해 개발자 VM을 사용하는 방법을 다룹니다.

---

## 13. Frozen Plugins

이 문서는 무한 루프나 장기 실행 작업으로 인해 Figma 플러그인 UI가 멈추는 문제를 다룹니다. 무한 루프의 경우 편집기 탭을 닫았다 다시 여는 것을 제안하고, 디버깅을 위해 개발자 도구의 "Sources" 탭을 사용할 것을 권장합니다. 장기 실행 작업의 경우, `setTimeout`을 사용하여 작업을 여러 조각으로 나누어 메인 스레드에 양보하거나, CSS 애니메이션을 사용하여 반응성을 인식시키거나, Figma 노드에 직접 접근할 필요가 없는 비싼 계산을 위해 WebWorker를 활용하는 해결책을 제시합니다.

## 14. Text Review Plugins

이 문서는 Figma 및 FigJam용 텍스트 검토 플러그인을 만드는 방법을 설명하며, 이는 기본 맞춤법 검사 기능을 보완하거나 대체할 수 있습니다. 이러한 플러그인은 철자, 문법, 스타일 또는 브랜딩 위반을 확인할 수 있으며, 사용자가 텍스트를 편집할 때 자동으로 활성화됩니다. 잘못된 텍스트 범위에 물결 모양의 밑줄을 표시하고 제안을 제공할 수 있습니다. 이 기능을 활성화하려면 플러그인의 기능에 "textreview"가 나열되어야 하며, `figma.textreview` API를 통해 플러그인이 사용자의 활성화 또는 비활성화를 요청할 수 있습니다.
